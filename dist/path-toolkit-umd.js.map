{"version":3,"file":"path-toolkit-umd.js","sources":["path-toolkit.js"],"sourcesContent":["/**\n * @fileOverview PathToolkit evaluates string paths as property/index sequences within objects and arrays\n * @author Aaron Brown\n * @version 1.0.0\n */\n\n// Parsing, tokeninzing, etc\n'use strict';\n\n// Some constants for convenience\nvar UNDEF = (function(u){return u;})();\n\n// Static strings, assigned to aid code minification\nvar $WILDCARD     = '*',\n    $UNDEFINED    = 'undefined',\n    $STRING       = 'string',\n    $PARENT       = 'parent',\n    $ROOT         = 'root',\n    $PLACEHOLDER  = 'placeholder',\n    $CONTEXT      = 'context',\n    $PROPERTY     = 'property',\n    $COLLECTION   = 'collection',\n    $EACH         = 'each',\n    $SINGLEQUOTE  = 'singlequote',\n    $DOUBLEQUOTE  = 'doublequote',\n    $CALL         = 'call',\n    $EVALPROPERTY = 'evalProperty';\n    \n/**\n * Tests whether a wildcard templates matches a given string.\n * ```javascript\n * var str = 'aaabbbxxxcccddd';\n * wildCardMatch('aaabbbxxxcccddd'); // true\n * wildCardMatch('*', str); // true\n * wildCardMatch('*', ''); // true\n * wildCardMatch('a*', str); // true\n * wildCardMatch('aa*ddd', str); // true\n * wildCardMatch('*d', str); // true\n * wildCardMatch('*a', str); // false\n * wildCardMatch('a*z', str); // false\n * ```\n * @private\n * @param  {String} template Wildcard pattern\n * @param  {String} str      String to match against wildcard pattern\n * @return {Boolean}          True if pattern matches string; False if not\n */\nvar wildCardMatch = function(template, str){\n    var pos = template.indexOf($WILDCARD),\n        parts = template.split($WILDCARD, 2),\n        match = true;\n    if (parts[0]){\n        // If no wildcard present, return simple string comparison\n        if (parts[0] === template){\n            return parts[0] === str;\n        }\n        else {\n            match = match && str.substr(0, parts[0].length) === parts[0];\n        }\n    }\n    if (parts[1]){\n        match = match && str.substr(-1*parts[1].length) === parts[1];\n    }\n    return match;\n};\n\n/**\n * Inspect input value and determine whether it is an Object or not.\n * Values of undefined and null will return \"false\", otherwise\n * must be of type \"object\" or \"function\".\n * @private\n * @param  {Object}  val Thing to examine, may be of any type\n * @return {Boolean}     True if thing is of type \"object\" or \"function\"\n */\nvar isObject = function(val){\n    if (typeof val === $UNDEFINED || val === null) { return false;}\n    return ( (typeof val === 'function') || (typeof val === 'object') );\n};\n\n/**\n * Convert various values to true boolean `true` or `false`.\n * For non-string values, the native javascript idea of \"true\" will apply.\n * For string values, the words \"true\", \"yes\", and \"on\" will all return `true`.\n * All other strings return `false`. The string match is non-case-sensitive.\n * @private\n */\nvar truthify = function(val){\n    var v;\n    if (typeof val !== $STRING){\n        return val && true; // Use native javascript notion of \"truthy\"\n    }\n    v = val.toUpperCase();\n    if (v === 'TRUE' || v === 'YES' || v === 'ON'){\n        return true;\n    }\n    return false;\n};\n\n/**\n * Using provided quote character as prefix and suffix, escape any instances\n * of the quote character within the string and return quote+string+quote.\n * The character defined as \"singlequote\" may be altered by custom options,\n * so a general-purpose function is needed to quote path segments correctly.\n * @private\n * @param  {String} q   Single-character string to use as quote character\n * @param  {String} str String to be quoted.\n * @return {String}     Original string, surrounded by the quote character, possibly modified internally if the quote character exists within the string.\n */\nvar quoteString = function(q, str){\n    var qRegEx = new RegExp(q, 'g');\n    return q + str.replace(qRegEx, '\\\\' + q) + q;\n};\n\n/**\n * PathToolkit base object. Includes all instance-specific data (options, cache)\n * as local variables. May be passed an options hash to pre-configure the\n * instance prior to use.\n * @constructor\n * @property {Object} options Optional. Collection of configuration settings for this instance of PathToolkit. See `setOptions` function below for detailed documentation.\n */\nvar PathToolkit = function(options){\n    var _this = this,\n        cache = {},\n        opt = {},\n        prefixList, separatorList, containerList, containerCloseList,\n        propertySeparator,\n        singlequote,\n        simplePathChars, simplePathRegEx,\n        allSpecials, allSpecialsRegEx,\n        escapedNonSpecialsRegEx,\n        wildcardRegEx;\n\n    /**\n     * Several regular expressions are pre-compiled for use in path interpretation.\n     * These expressions are built from the current syntax configuration, so they\n     * must be re-built every time the syntax changes.\n     * @private\n     */\n    var updateRegEx = function(){\n        // Lists of special characters for use in regular expressions\n        prefixList = Object.keys(opt.prefixes);\n        separatorList = Object.keys(opt.separators);\n        containerList = Object.keys(opt.containers);\n        containerCloseList = containerList.map(function(key){ return opt.containers[key].closer; });\n        \n        propertySeparator = '';\n        Object.keys(opt.separators).forEach(function(sep){ if (opt.separators[sep].exec === $PROPERTY){ propertySeparator = sep; } });\n        singlequote = '';\n        Object.keys(opt.containers).forEach(function(sep){ if (opt.containers[sep].exec === $SINGLEQUOTE){ singlequote = sep; } });\n\n        // Find all special characters except property separator (. by default)\n        simplePathChars = '[\\\\\\\\' + [$WILDCARD].concat(prefixList).concat(separatorList).concat(containerList).join('\\\\').replace('\\\\'+propertySeparator, '') + ']';\n        simplePathRegEx = new RegExp(simplePathChars);\n        \n        // Find all special characters, including backslash\n        allSpecials = '[\\\\\\\\\\\\' + [$WILDCARD].concat(prefixList).concat(separatorList).concat(containerList).concat(containerCloseList).join('\\\\') + ']';\n        allSpecialsRegEx = new RegExp(allSpecials, 'g');\n        \n        // Find all escaped special characters\n        // escapedSpecialsRegEx = new RegExp('\\\\'+allSpecials, 'g');\n        // Find all escaped non-special characters, i.e. unnecessary escapes\n        escapedNonSpecialsRegEx = new RegExp('\\\\'+allSpecials.replace(/^\\[/,'[^'));\n        \n        // Find wildcard character\n        wildcardRegEx = new RegExp('\\\\'+$WILDCARD);\n    };\n\n    /**\n     * Sets all the default options for interpreter behavior and syntax.\n     * @private\n     */\n    var setDefaultOptions = function(){\n        opt = opt || {};\n        // Default settings\n        opt.useCache = true;  // cache tokenized paths for repeated use\n        opt.simple = false;   // only support dot-separated paths, no other special characters\n        opt.force = false;    // create intermediate properties during `set` operation\n\n        // Default prefix special characters\n        opt.prefixes = {\n            '^': {\n                'exec': $PARENT\n            },\n            '~': {\n                'exec': $ROOT\n            },\n            '%': {\n                'exec': $PLACEHOLDER\n            },\n            '@': {\n                'exec': $CONTEXT\n            }\n        };\n        // Default separator special characters\n        opt.separators = {\n            '.': {\n                'exec': $PROPERTY\n                },\n            ',': {\n                'exec': $COLLECTION\n                },\n            '<': {\n                'exec': $EACH\n            }\n        };\n        // Default container special characters\n        opt.containers = {\n            '[': {\n                'closer': ']',\n                'exec': $PROPERTY\n                },\n            '\\'': {\n                'closer': '\\'',\n                'exec': $SINGLEQUOTE\n                },\n            '\"': {\n                'closer': '\"',\n                'exec': $DOUBLEQUOTE\n                },\n            '(': {\n                'closer': ')',\n                'exec': $CALL\n                },\n            '{': {\n                'closer': '}',\n                'exec': $EVALPROPERTY\n                }\n        };\n    };\n\n    /**\n     * Scan input string from left to right, one character at a time. If a special character\n     * is found (one of \"separators\", \"containers\", or \"prefixes\"), either store the accumulated\n     * word as a token or else begin watching input for end of token (finding a closing character\n     * for a container or the end of a collection). If a container is found, capture the substring\n     * within the container and recursively call `tokenize` on that substring. Final output will\n     * be an array of tokens. A complex token (not a simple property or index) will be represented\n     * as an object carrying metadata for processing.\n     * @private\n     * @param  {String} str Path string\n     * @return {Array}     Array of tokens found in the input path\n     */\n    var tokenize = function (str){\n        var path = '',\n            simplePath = true, // path is assumed \"simple\" until proven otherwise\n            tokens = [],\n            recur = [],\n            mods = {},\n            pathLength = 0,\n            word = '',\n            hasWildcard = false,\n            doEach = false, // must remember the \"each\" operator into the following token\n            subpath = '',\n            i = 0,\n            opener = '',\n            closer = '',\n            separator = '',\n            collection = [],\n            depth = 0,\n            escaped = 0;\n\n        if (opt.useCache && cache[str] !== UNDEF){ return cache[str]; }\n\n        // Strip out any unnecessary escaping to simplify processing below\n        path = str.replace(escapedNonSpecialsRegEx, '$&'.substr(1));\n        pathLength = path.length;\n\n        if (typeof str === $STRING && !simplePathRegEx.test(str)){\n            tokens = path.split(propertySeparator);\n            opt.useCache && (cache[str] = {t: tokens, simple: simplePath});\n            return {t: tokens, simple: simplePath};\n        }\n\n        for (i = 0; i < pathLength; i++){\n            // Skip escape character (`\\`) and set \"escaped\" to the index value\n            // of the character to be treated as a literal\n            if (!escaped && path[i] === '\\\\'){\n                // Next character is the escaped character\n                escaped = i+1;\n                i++;\n            }\n            // If a wildcard character is found, mark this token as having a wildcard\n            if (path[i] === $WILDCARD) {\n                hasWildcard = true;\n            }\n            // If we have already processed a container opener, treat this subpath specially\n            if (depth > 0){\n                // Is this character another opener from the same container? If so, add to\n                // the depth level so we can match the closers correctly. (Except for quotes\n                // which cannot be nested)\n                // Is this character the closer? If so, back out one level of depth.\n                // Be careful: quote container uses same character for opener and closer.\n                !escaped && path[i] === opener && opener !== closer.closer && depth++;\n                !escaped && path[i] === closer.closer && depth--;\n\n                // While still inside the container, just add to the subpath\n                if (depth > 0){\n                    subpath += path[i];\n                }\n                // When we close off the container, time to process the subpath and add results to our tokens\n                else {\n                    // Handle subpath \"[bar]\" in foo.[bar],[baz] - we must process subpath and create a new collection\n                    if (i+1 < pathLength && opt.separators[path[i+1]] && opt.separators[path[i+1]].exec === $COLLECTION){\n                        recur = tokenize(subpath);\n                        if (recur === UNDEF){ return undefined; }\n                        recur.exec = closer.exec;\n                        recur.doEach = doEach;\n                        collection.push(recur);\n                    }\n                    // Handle subpath \"[baz]\" in foo.[bar],[baz] - we must process subpath and add to collection\n                    else if (collection[0]){\n                        recur = tokenize(subpath);\n                        if (recur === UNDEF){ return undefined; }\n                        recur.exec = closer.exec;\n                        recur.doEach = doEach;\n                        collection.push(recur);\n                        tokens.push(collection);\n                        collection = [];\n                        simplePath &= false;\n                    }\n                    // Simple property container is equivalent to dot-separated token. Just add this token to tokens.\n                    else if (closer.exec === $PROPERTY){\n                        recur = tokenize(subpath);\n                        if (recur === UNDEF){ return undefined; }\n                        if (doEach){\n                            tokens = tokens.concat({'w':recur.t, 'mods':{}, 'doEach':true});\n                            simplePath &= false;\n                            doEach = false; // reset\n                        }\n                        else {\n                            tokens = tokens.concat(recur.t);\n                            simplePath &= recur.simple;\n                        }\n                    }\n                    // Quoted subpath is all taken literally without token evaluation. Just add subpath to tokens as-is.\n                    else if (closer.exec === $SINGLEQUOTE || closer.exec === $DOUBLEQUOTE){\n                        tokens.push(subpath);\n                        simplePath &= true;\n                    }\n                    // Otherwise, create token object to hold tokenized subpath, add to tokens.\n                    else {\n                        if (subpath === ''){\n                            recur = {t:[],simple:true};\n                        }\n                        else {\n                            recur = tokenize(subpath);\n                        }\n                        if (recur === UNDEF){ return undefined; }\n                        recur.exec = closer.exec;\n                        recur.doEach = doEach;\n                        tokens.push(recur);\n                        simplePath &= false;\n                    }\n                    subpath = ''; // reset subpath\n                }\n            }\n            // If a prefix character is found, store it in `mods` for later reference.\n            // Must keep count due to `parent` prefix that can be used multiple times in one token.\n            else if (!escaped && path[i] in opt.prefixes && opt.prefixes[path[i]].exec){\n                mods.has = true;\n                if (mods[opt.prefixes[path[i]].exec]) { mods[opt.prefixes[path[i]].exec]++; }\n                else { mods[opt.prefixes[path[i]].exec] = 1; }\n            }\n            // If a separator is found, time to store the token we've been accumulating. If\n            // this token had a prefix, we store the token as an object with modifier data.\n            // If the separator is the collection separator, we must either create or add\n            // to a collection for this token. For simple separator, we either add the token\n            // to the token list or else add to the existing collection if it exists.\n            else if (!escaped && opt.separators.hasOwnProperty(path[i]) && opt.separators[path[i]].exec){\n                separator = opt.separators[path[i]];\n                if (!word && (mods.has || hasWildcard)){\n                    // found a separator, after seeing prefixes, but no token word -> invalid\n                    return undefined;\n                }\n                // This token will require special interpreter processing due to prefix or wildcard.\n                if (word && (mods.has || hasWildcard || doEach)){\n                    word = {'w': word, 'mods': mods, 'doEach': doEach};\n                    mods = {};\n                    simplePath &= false;\n                }\n                // word is a plain property or end of collection\n                if (separator.exec === $PROPERTY || separator.exec === $EACH){\n                    // we are gathering a collection, so add last word to collection and then store\n                    if (collection[0] !== UNDEF){\n                        word && collection.push(word);\n                        if (doEach){\n                            tokens.push({'t':collection, 'doEach':true});\n                        }\n                        else {\n                            tokens.push(collection);\n                        }\n                        collection = []; // reset\n                        simplePath &= false;\n                    }\n                    // word is a plain property\n                    else {\n                        word && tokens.push(word);\n                        simplePath &= true;\n                    }\n                    // If the separator is the \"each\" separtor, the following word will be evaluated differently.\n                    // If it's not the \"each\" separator, then reset \"doEach\"\n                    doEach = separator.exec === $EACH; // reset\n                }\n                // word is a collection\n                else if (separator.exec === $COLLECTION){\n                    word && collection.push(word);\n                }\n                word = ''; // reset\n                hasWildcard = false; // reset\n            }\n            // Found a container opening character. A container opening is equivalent to\n            // finding a separator, so \"foo.bar\" is equivalent to \"foo[bar]\", so apply similar\n            // process as separator above with respect to token we have accumulated so far.\n            // Except in case collections - path may have a collection of containers, so\n            // in \"foo[bar],[baz]\", the \"[bar]\" marks the end of token \"foo\", but \"[baz]\" is\n            // merely another entry in the collection, so we don't close off the collection token\n            // yet.\n            // Set depth value for further processing.\n            else if (!escaped && opt.containers.hasOwnProperty(path[i]) && opt.containers[path[i]].exec){\n                closer = opt.containers[path[i]];\n                if (word && (mods.has || hasWildcard || doEach)){\n                    if (typeof word === 'string'){\n                        word = {'w': word, 'mods': mods, 'doEach':doEach};\n                    }\n                    else {\n                        word.mods = mods;\n                        word.doEach = doEach;\n                    }\n                    mods = {};\n                }\n                if (collection[0] !== UNDEF){\n                    // we are gathering a collection, so add last word to collection and then store\n                    word && collection.push(word);\n                }\n                else {\n                    // word is a plain property\n                    word && tokens.push(word);\n                    simplePath &= true;\n                }\n                opener = path[i];\n                // 1) don't reset doEach for empty word because this is [foo]<[bar]\n                // 2) don't reset doEach for opening Call because this is a,b<fn()\n                if (word && opt.containers[opener].exec !== $CALL){\n                    doEach = false;\n                }\n                word = '';\n                hasWildcard = false;\n                depth++;\n            }\n            // Otherwise, this is just another character to add to the current token\n            else if (i < pathLength) {\n                word += path[i];\n            }\n\n            // If current path index matches the escape index value, reset `escaped`\n            if (i < pathLength && i === escaped){\n                escaped = 0;\n            }\n        }\n\n        // Path ended in an escape character\n        if (escaped){\n            return undefined;\n        }\n\n        // Add trailing word to tokens, if present\n        if (typeof word === 'string' && word && (mods.has || hasWildcard || doEach)){\n            word = {'w': word, 'mods': mods, 'doEach': doEach};\n            mods = {};\n            simplePath &= false;\n        }\n        else if (word && word.mods){\n            word.mods = mods;\n        }\n        // We are gathering a collection, so add last word to collection and then store\n        if (collection[0] !== UNDEF){\n            word && collection.push(word);\n            tokens.push(collection);\n            simplePath &= false;\n        }\n        // Word is a plain property\n        else {\n            word && tokens.push(word);\n            simplePath &= true;\n        }\n\n        // depth != 0 means mismatched containers\n        if (depth !== 0){ return undefined; }\n\n        // If path was valid, cache the result\n        opt.useCache && (cache[str] = {t: tokens, simple: simplePath});\n\n        return {t: tokens, simple: simplePath};\n    };\n\n    /**\n     * It is `resolvePath`'s job to traverse an object according to the tokens\n     * derived from the keypath and either return the value found there or set\n     * a new value in that location.\n     * The tokens are a simple array and `reoslvePath` loops through the list\n     * with a simple \"while\" loop. A token may itself be a nested token array,\n     * which is processed through recursion.\n     * As each successive value is resolved within `obj`, the current value is\n     * pushed onto the \"valueStack\", enabling backward references (upwards in `obj`)\n     * through path prefixes like \"<\" for \"parent\" and \"~\" for \"root\". The loop\n     * short-circuits by returning `undefined` if the path is invalid at any point,\n     * except in `set` scenario with `force` enabled.\n     * @private\n     * @param  {Object} obj        The data object to be read/written\n     * @param  {String} path       The keypath which `resolvePath` will evaluate against `obj`. May be a pre-compiled Tokens set instead of a string.\n     * @param  {Any} newValue   The new value to set at the point described by `path`. Undefined if used in `get` scenario.\n     * @param  {Array} args       Array of extra arguments which may be referenced by placeholders. Undefined if no extra arguments were given.\n     * @param  {Array} valueStack Stack of object contexts accumulated as the path tokens are processed in `obj`\n     * @return {Any}            In `get`, returns the value found in `obj` at `path`. In `set`, returns the new value that was set in `obj`. If `get` or `set` are nto successful, returns `undefined`\n     */\n    var resolvePath = function (obj, path, newValue, args, valueStack){\n        var change = newValue !== UNDEF, // are we setting a new value?\n            tk = [],\n            tkLength = 0,\n            tkLastIdx = 0,\n            valueStackLength = 1,\n            i = 0,\n            prev = obj,\n            curr = '',\n            currLength = 0,\n            wordCopy = '',\n            contextProp,\n            idx = 0,\n            context = obj,\n            ret,\n            newValueHere = false,\n            placeInt = 0,\n            prop = '',\n            callArgs;\n\n        // For String path, either fetch tokens from cache or from `tokenize`.\n        if (typeof path === $STRING){\n            if (opt.useCache && cache[path]) { tk = cache[path].t; }\n            else {\n                tk = tokenize(path);\n                if (tk === UNDEF){ return undefined; }\n                tk = tk.t;\n            }\n        }\n        // For a non-string, assume a pre-compiled token array\n        else {\n            tk = path.t ? path.t : [path];\n        }\n\n        tkLength = tk.length;\n        if (tkLength === 0) { return undefined; }\n        tkLastIdx = tkLength - 1;\n\n        // valueStack will be an array if we are within a recursive call to `resolvePath`\n        if (valueStack){\n            valueStackLength = valueStack.length;\n        }\n        // On original entry to `resolvePath`, initialize valueStack with the base object.\n        // valueStackLength was already initialized to 1.\n        else {\n            valueStack = [obj];\n        }\n\n        // Converted Array.reduce into while loop, still using \"prev\", \"curr\", \"idx\"\n        // as loop values\n        while (prev !== UNDEF && idx < tkLength){\n            curr = tk[idx];\n\n            // If we are setting a new value and this token is the last token, this\n            // is the point where the new value must be set.\n            newValueHere = (change && (idx === tkLastIdx));\n\n            // Handle most common simple path scenario first\n            if (typeof curr === $STRING){\n                // If we are setting...\n                if (change){\n                    // If this is the final token where the new value goes, set it\n                    if (newValueHere){\n                        context[curr] = newValue;\n                        if (context[curr] !== newValue){ return undefined; } // new value failed to set\n                    }\n                    // For earlier tokens, create object properties if \"force\" is enabled\n                    else if (opt.force && (Array.isArray(prev) ? context[curr] !== UNDEF : !context.hasOwnProperty(curr))) {\n                        context[curr] = {};\n                    }\n                }\n                // Return value is assigned as value of this object property\n                ret = context[curr];\n\n                // This basic structure is repeated in other scenarios below, so the logic\n                // pattern is only documented here for brevity.\n            }\n            else {\n                if (curr === UNDEF){\n                    ret = undefined;\n                }\n                else if (Array.isArray(curr)){\n                    // Call resolvePath again with base value as evaluated value so far and\n                    // each element of array as the path. Concat all the results together.\n                    ret = [];\n                    i = 0;\n                    while(typeof curr[i] !== 'undefined'){\n                        if (newValueHere){\n                            contextProp = resolvePath(context, curr[i], newValue, args, valueStack.slice());\n                        }\n                        else {\n                            contextProp = resolvePath(context, curr[i], undefined, args, valueStack.slice());\n                        }\n                        if (contextProp === UNDEF) { return undefined; }\n\n                        if (newValueHere){\n                            if (curr[i].t && curr[i].exec === $EVALPROPERTY){\n                                context[contextProp] = newValue;\n                            } else {\n                                ret.push(contextProp);\n                            }\n                        }\n                        else {\n                            if (curr[i].t && curr[i].exec === $EVALPROPERTY){\n                                ret.push(context[contextProp]);\n                            } else {\n                                ret.push(contextProp);\n                            }\n                        }\n                        i++;\n                    }\n                }\n                else if (curr.w){\n                    // this word token has modifiers\n                    wordCopy = curr.w + '';\n                    if (curr.mods.parent){\n                        // modify current context, shift upwards in base object one level\n                        context = valueStack[valueStackLength - 1 - curr.mods.parent];\n                        if (context === UNDEF) { return undefined; }\n                    }\n                    if (curr.mods.root){\n                        // Reset context and valueStack, start over at root in this context\n                        context = valueStack[0];\n                        valueStack = [context];\n                        valueStackLength = 1;\n                    }\n                    if (curr.mods.placeholder){\n                        placeInt = wordCopy - 1;\n                        if (args[placeInt] === UNDEF){ return undefined; }\n                        // Force args[placeInt] to String, won't atwordCopyt to process\n                        // arg of type function, array, or plain object\n                        wordCopy = args[placeInt].toString();\n                    }\n\n                    // doEach option means to take all values in context (must be an array), apply\n                    // \"curr\" to each one, and return the new array. Operates like Array.map.\n                    if (curr.doEach){\n                        if (!Array.isArray(context)){\n                            return undefined;\n                        }\n                        ret = [];\n                        i = 0;\n                        while(typeof context[i] !== 'undefined'){\n                            // \"context\" modifier (\"@\" by default) replaces current context with a value from\n                            // the arguments.\n                            if (curr.mods.context){\n                                placeInt = wordCopy - 1;\n                                if (args[placeInt] === UNDEF){ return undefined; }\n                                // Force args[placeInt] to String, won't atwordCopyt to process\n                                // arg of type function, array, or plain object\n                                ret.push(args[placeInt]);\n                            }\n                            else {\n                                // Repeat basic string property processing with word and modified context\n                                if (context[i][wordCopy] !== UNDEF) {\n                                    if (newValueHere){ context[i][wordCopy] = newValue; }\n                                    ret.push(context[i][wordCopy]);\n                                }\n                                else if (typeof context[i] === 'function'){\n                                    ret.push(wordCopy);\n                                }\n                                // Plain property tokens are listed as special word tokens whenever\n                                // a wildcard is found within the property string. A wildcard in a\n                                // property causes an array of matching properties to be returned,\n                                // so loop through all properties and evaluate token for every\n                                // property where `wildCardMatch` returns true.\n                                else if (wildcardRegEx.test(wordCopy)){\n                                    ret.push([]);\n                                    for (prop in context[i]){\n                                        if (context[i].hasOwnProperty(prop) && wildCardMatch(wordCopy, prop)){\n                                            if (newValueHere){ context[i][prop] = newValue; }\n                                            ret[i].push(context[i][prop]);\n                                        }\n                                    }\n                                }\n                                else { return undefined; }\n                            }\n                            i++;\n                        }\n                    }\n                    else {\n                        // \"context\" modifier (\"@\" by default) replaces current context with a value from\n                        // the arguments.\n                        if (curr.mods.context){\n                            placeInt = wordCopy - 1;\n                            if (args[placeInt] === UNDEF){ return undefined; }\n                            // Force args[placeInt] to String, won't atwordCopyt to process\n                            // arg of type function, array, or plain object\n                            ret = args[placeInt];\n                        }\n                        else {\n                            // Repeat basic string property processing with word and modified context\n                            if (context[wordCopy] !== UNDEF) {\n                                if (newValueHere){ context[wordCopy] = newValue; }\n                                ret = context[wordCopy];\n                            }\n                            else if (typeof context === 'function'){\n                                \n                                ret = wordCopy;\n                            }\n                            // Plain property tokens are listed as special word tokens whenever\n                            // a wildcard is found within the property string. A wildcard in a\n                            // property causes an array of matching properties to be returned,\n                            // so loop through all properties and evaluate token for every\n                            // property where `wildCardMatch` returns true.\n                            else if (wildcardRegEx.test(wordCopy)){\n                                ret = [];\n                                for (prop in context){\n                                    if (context.hasOwnProperty(prop) && wildCardMatch(wordCopy, prop)){\n                                        if (newValueHere){ context[prop] = newValue; }\n                                        ret.push(context[prop]);\n                                    }\n                                }\n                            }\n                            else { return undefined; }\n                        }\n                    }\n                }\n                // Eval Property tokens operate on a temporary context created by\n                // recursively calling `resolvePath` with a copy of the valueStack.\n                else if (curr.exec === $EVALPROPERTY){\n                    if (curr.doEach){\n                        if (!Array.isArray(context)){\n                            return undefined;\n                        }\n                        ret = [];\n                        i = 0;\n                        while(typeof context[i] !== 'undefined'){\n                            if (newValueHere){\n                                context[i][resolvePath(context[i], curr, UNDEF, args, valueStack.slice())] = newValue;\n                            }\n                            ret.push(context[i][resolvePath(context[i], curr, UNDEF, args, valueStack.slice())]);\n                            i++;\n                        }\n                    }\n                    else {\n                        if (newValueHere){\n                            context[resolvePath(context, curr, UNDEF, args, valueStack.slice())] = newValue;\n                        }\n                        ret = context[resolvePath(context, curr, UNDEF, args, valueStack.slice())];\n                    }\n                }\n                // Functions are called using `call` or `apply`, depending on the state of\n                // the arguments within the ( ) container. Functions are executed with \"this\"\n                // set to the context immediately prior to the function in the stack.\n                // For example, \"a.b.c.fn()\" is equivalent to obj.a.b.c.fn.call(obj.a.b.c)\n                else if (curr.exec === $CALL){\n                    if (curr.doEach){\n                        if (!Array.isArray(valueStack[valueStackLength - 2])){\n                            return undefined;\n                        }\n                        ret = [];\n                        i = 0;\n                        while(typeof context[i] !== 'undefined'){\n                            // If function call has arguments, process those arguments as a new path\n                            if (curr.t && curr.t.length){\n                                callArgs = resolvePath(context, curr, UNDEF, args, valueStack.slice());\n                                if (callArgs === UNDEF){\n                                    ret.push(context[i].apply(valueStack[valueStackLength - 2][i]));\n                                }\n                                else if (Array.isArray(callArgs)){\n                                    ret.push(context[i].apply(valueStack[valueStackLength - 2][i], callArgs));\n                                }\n                                else {\n                                    ret.push(context[i].call(valueStack[valueStackLength - 2][i], callArgs));\n                                }\n                            }\n                            else {\n                                ret.push(context[i].call(valueStack[valueStackLength - 2][i]));\n                            }\n                            i++;\n                        }\n                    }\n                    else {\n                        // If function call has arguments, process those arguments as a new path\n                        if (curr.t && curr.t.length){\n                            callArgs = resolvePath(context, curr, UNDEF, args, valueStack.slice());\n                            if (callArgs === UNDEF){\n                                ret = context.apply(valueStack[valueStackLength - 2]);\n                            }\n                            else if (Array.isArray(callArgs)){\n                                ret = context.apply(valueStack[valueStackLength - 2], callArgs);\n                            }\n                            else {\n                                ret = context.call(valueStack[valueStackLength - 2], callArgs);\n                            }\n                        }\n                        else {\n                            ret = context.call(valueStack[valueStackLength - 2]);\n                        }\n                    }\n                }\n            }\n            // Add the return value to the stack in case we must loop again\n            valueStack.push(ret);\n            valueStackLength++;\n            context = ret;\n            prev = ret;\n            idx++;\n        }\n        return context;\n    };\n\n    /**\n     * Simplified path evaluation heavily optimized for performance when\n     * processing paths with only property names or indices and separators.\n     * If the path can be correctly processed with \"path.split(separator)\",\n     * this function will do so. Any other special characters found in the\n     * path will cause the path to be evaluated with the full `resolvePath`\n     * function instead.\n     * @private\n     * @param  {Object} obj        The data object to be read/written\n     * @param  {String} path       The keypath which `resolvePath` will evaluate against `obj`.\n     * @param  {Any} newValue   The new value to set at the point described by `path`. Undefined if used in `get` scenario.\n     * @return {Any}            In `get`, returns the value found in `obj` at `path`. In `set`, returns the new value that was set in `obj`. If `get` or `set` are nto successful, returns `undefined`\n     */\n    var quickResolveString = function(obj, path, newValue){\n        var change = newValue !== UNDEF,\n            tk = [],\n            i = 0,\n            tkLength = 0;\n\n        tk = path.split(propertySeparator);\n        opt.useCache && (cache[path] = {t: tk, simple: true});\n        tkLength = tk.length;\n        while (obj !== UNDEF && i < tkLength){\n            if (tk[i] === ''){ return undefined; }\n            else if (change){\n                if (i === tkLength - 1){\n                    obj[tk[i]] = newValue;\n                }\n                // For arrays, test current context against undefined to avoid parsing this segment as a number.\n                // For anything else, use hasOwnProperty.\n                else if (opt.force && (Array.isArray(obj) ? obj[tk[i]] !== UNDEF : !obj.hasOwnProperty(tk[i]))) {\n                    obj[tk[i]] = {};\n                }\n            }\n            obj = obj[tk[i++]];\n        }\n        return obj;\n    };\n\n    /**\n     * Simplified path evaluation heavily optimized for performance when\n     * processing array of simple path tokens (plain property names).\n     * This function is essentially the same as `quickResolveString` except\n     * `quickResolveTokenArray` does nto need to execute path.split.\n     * @private\n     * @param  {Object} obj        The data object to be read/written\n     * @param  {Array} tk       The token array which `resolvePath` will evaluate against `obj`.\n     * @param  {Any} newValue   The new value to set at the point described by `path`. Undefined if used in `get` scenario.\n     * @return {Any}            In `get`, returns the value found in `obj` at `path`. In `set`, returns the new value that was set in `obj`. If `get` or `set` are nto successful, returns `undefined`\n     */\n    var quickResolveTokenArray = function(obj, tk, newValue){\n        var change = newValue !== UNDEF,\n            i = 0,\n            tkLength = tk.length;\n\n        while (obj != null && i < tkLength){\n            if (tk[i] === ''){ return undefined; }\n            else if (change){\n                if (i === tkLength - 1){\n                    obj[tk[i]] = newValue;\n                }\n                // For arrays, test current context against undefined to avoid parsing this segment as a number.\n                // For anything else, use hasOwnProperty.\n                else if (opt.force && (Array.isArray(obj) ? obj[tk[i]] !== UNDEF : !obj.hasOwnProperty(tk[i]))) {\n                    obj[tk[i]] = {};\n                }\n            }\n            obj = obj[tk[i++]];\n        }\n        return obj;\n    };\n\n    /**\n     * Searches an object or array for a value, accumulating the keypath to the value along\n     * the way. Operates in a recursive way until either all keys/indices have been\n     * exhausted or a match is found. Return value \"true\" means \"keep scanning\", \"false\"\n     * means \"stop now\". If a match is found, instead of returning a simple \"false\", a\n     * callback function (savePath) is called which will decide whether or not to continue\n     * the scan. This allows the function to find one instance of value or all instances,\n     * based on logic in the callback.\n     * @private\n     * @param {Object} obj    The data object to scan\n     * @param {Any} val The value we are looking for within `obj`\n     * @param {Function} savePath Callback function which will store accumulated paths and indicate whether to continue\n     * @param {String} path Accumulated keypath; undefined at first, populated in recursive calls\n     * @return {Boolean} Indicates whether scan process should continue (\"true\"->yes, \"false\"->no)\n     */\n    var scanForValue = function(obj, val, savePath, path){\n        var i, len, more, keys, prop;\n\n        path = path ? path : '';\n\n        // If we found the value we're looking for\n        if (obj === val){\n            return savePath(path); // Save the accumulated path, ask whether to continue\n        }\n        // This object is an array, so examine each index separately\n        else if (Array.isArray(obj)){\n            len = obj.length;\n            for(i = 0; i < len; i++){\n                // Call `scanForValue` recursively\n                more = scanForValue(obj[i], val, savePath, path + propertySeparator + i);\n                // Halt if that recursive call returned \"false\"\n                if (!more){ return; }\n            }\n            return true; // keep looking\n        }\n        // This object is an object, so examine each local property separately\n        else if (isObject(obj)) {\n            keys = Object.keys(obj);\n            len = keys.length;\n            if (len > 1){ keys = keys.sort(); } // Force order of object keys to produce repeatable results\n            for (i = 0; i < len; i++){\n                if (obj.hasOwnProperty(keys[i])){\n                    prop = keys[i];\n                    // Property may include the separator character or some other special character,\n                    // so quote this path segment and escape any separators within.\n                    if (allSpecialsRegEx.test(prop)){\n                        prop = quoteString(singlequote, prop);\n                    }\n                    more = scanForValue(obj[keys[i]], val, savePath, path + propertySeparator + prop);\n                    if (!more){ return; }\n                }\n            }\n            return true; // keep looking\n        }\n        // Leaf node (string, number, character, boolean, etc.), but didn't match\n        return true; // keep looking\n    };\n\n    /**\n     * Get tokenized representation of string keypath.\n     * @public\n     * @param {String} path Keypath\n     * @return {Object} Object including the array of path tokens and a boolean indicating \"simple\". Simple token sets have no special operators or nested tokens, only a plain array of strings for fast evaluation.\n     */\n    _this.getTokens = function(path){\n        var tokens = tokenize(path);\n        if (typeof tokens === $UNDEFINED){ return undefined; }\n        return tokens;\n    };\n\n    /**\n     * Informs whether the string path has valid syntax. The path is NOT evaluated against a\n     * data object, only the syntax is checked.\n     * @public\n     * @param {String} path Keypath\n     * @return {Boolean} valid syntax -> \"true\"; not valid -> \"false\"\n     */\n    _this.isValid = function(path){\n        return typeof tokenize(path) !== $UNDEFINED;\n    };\n\n    /**\n     * Escapes any special characters found in the input string using backslash, preventing\n     * these characters from causing unintended processing by PathToolkit. This function\n     * DOES respect the current configured syntax, even if it has been altered from the default.\n     * @public\n     * @param {String} segment Segment of a keypath\n     * @return {String} The original segment string with all PathToolkit special characters prepended with \"\\\"\n     */\n    _this.escape = function(segment){\n        return segment.replace(allSpecialsRegEx, '\\\\$&');\n    };\n\n    /**\n     * Evaluates keypath in object and returns the value found there, if available. If the path\n     * does not exist in the provided data object, returns `undefined`. For \"simple\" paths, which\n     * don't include any operations beyond property separators, optimized resolvers will be used\n     * which are more lightweight than the full-featured `resolvePath`.\n     * @public\n     * @param {Any} obj Source data object\n     * @param {String} path Keypath to evaluate within \"obj\". Also accepts token array in place of a string path.\n     * @return {Any} If the keypath exists in \"obj\", return the value at that location; If not, return `undefined`.\n     */\n    _this.get = function (obj, path){\n        var i = 0,\n            len = arguments.length,\n            args;\n        // For string paths, first see if path has already been cached and if the token set is simple. If\n        // so, we can use the optimized token array resolver using the cached token set.\n        // If there is no cached entry, use RegEx to look for special characters apart from the separator.\n        // If none are found, we can use the optimized string resolver.\n        if (typeof path === $STRING){\n            if (opt.useCache && cache[path] && cache[path].simple){\n                return quickResolveTokenArray(obj, cache[path].t);\n            }\n            else if (!simplePathRegEx.test(path)){\n                return quickResolveString(obj, path);\n            }\n        }\n        // For array paths (pre-compiled token sets), check for simplicity so we can use the optimized resolver.\n        else if (Object.hasOwnProperty.call(path, 't') && Array.isArray(path.t) && path.simple){\n            return quickResolveTokenArray(obj, path.t);\n        }\n        \n        // If we made it this far, the path is complex and may include placeholders. Gather up any\n        // extra arguments and call the full `resolvePath` function.\n        args = [];\n        if (len > 2){\n            for (i = 2; i < len; i++) { args[i-2] = arguments[i]; }\n        }\n        return resolvePath(obj, path, undefined, args);\n    };\n\n    /**\n     * Evaluates a keypath in object and sets a new value at the point described in the keypath. If\n     * \"force\" is disabled, the full path must exist up to the final property, which may be created\n     * by the set operation. If \"force\" is enabled, any missing intermediate properties will be created\n     * in order to set the value on the final property. If `set` succeeds, returns \"true\", otherwise \"false\".\n     * @public\n     * @param {Any} obj Source data object\n     * @param {String} path Keypath to evaluate within \"obj\". Also accepts token array in place of a string path.\n     * @param {Any} val New value to set at the location described in \"path\"\n     * @return {Boolean} \"true\" if the set operation succeeds; \"false\" if it does not succeed\n     */\n    _this.set = function(obj, path, val){\n        var i = 0,\n            len = arguments.length,\n            args,\n            ref,\n            done = false;\n            \n        // Path resolution follows the same logic as `get` above, with one difference: `get` will\n        // abort by returning the value as soon as it's found. `set` does not abort so the if-else\n        // structure is slightly different to dictate when/if the final case should execute.\n        if (typeof path === $STRING){\n            if (opt.useCache && cache[path] && cache[path].simple){\n                ref = quickResolveTokenArray(obj, cache[path].t, val);\n                done |= true;\n            }\n            else if (!simplePathRegEx.test(path)){\n                ref = quickResolveString(obj, path, val);\n                done |= true;\n            }\n        }\n        else if (Object.hasOwnProperty.call(path, 't') && Array.isArray(path.t) && path.simple){\n            ref = quickResolveTokenArray(obj, path.t, val);\n            done |= true;\n        }\n        \n        // Path was (probably) a string and it contained complex path characters\n        if (!done) {\n            if (len > 3){\n                args = [];\n                for (i = 3; i < len; i++) { args[i-3] = arguments[i]; }\n            }\n            ref = resolvePath(obj, path, val, args);\n        }\n        \n        // `set` can set a new value in multiple places if the final path segment is an array.\n        // If any of those value assignments fail, `set` will return \"false\" indicating failure.\n        if (Array.isArray(ref)){\n            return ref.indexOf(undefined) === -1;\n        }\n        return ref !== UNDEF;\n    };\n\n    /**\n     * Locate a value within an object or array. This is the publicly exposed interface to the\n     * private `scanForValue` function defined above.\n     * @public\n     * @param {Any} obj Source data object\n     * @param {Any} val The value to search for within \"obj\"\n     * @param {String} oneOrMany Optional; If missing or \"one\", `find` will only return the first valid path. If \"onOrMany\" is any other string, `find` will scan the full object looking for all valid paths to all cases where \"val\" appears.\n     * @return {Array} Array of keypaths to \"val\" or `undefined` if \"val\" is not found.\n     */\n    _this.find = function(obj, val, oneOrMany){\n        var retVal = [];\n        // savePath is the callback which will accumulate any found paths in a local array\n        // variable.\n        var savePath = function(path){\n            retVal.push(path.substr(1));\n            if(!oneOrMany || oneOrMany === 'one'){\n                retVal = retVal[0];\n                return false;\n            }\n            return true;\n        };\n        scanForValue(obj, val, savePath);\n        return retVal[0] ? retVal : undefined;\n    };\n\n    /**\n     * For a given special character group (e.g., separators) and character type (e.g., \"property\"),\n     * replace an existing separator with a new character. This creates a new special character for\n     * that purpose anwithin the character group and removes the old one. Also takes a \"closer\" argument\n     * for cases where the special character is a container set.\n     * @private\n     * @param {Object} optionGroup Reference to current configuration for a certain type of special characters\n     * @param {String} charType The type of special character to be replaced\n     * @param {String} val New special character string\n     * @param {String} closer Optional; New special character closer string, only used for \"containers\" group\n     */\n    var updateOptionChar = function(optionGroup, charType, val, closer){\n        var oldVal = '';\n        Object.keys(optionGroup).forEach(function(str){ if (optionGroup[str].exec === charType){ oldVal = str; } });\n\n        delete optionGroup[oldVal];\n        optionGroup[val] = {exec: charType};\n        if (closer){ optionGroup[val].closer = closer; }\n    };\n\n    /**\n     * Sets \"simple\" syntax in special character groups. This syntax only supports a separator\n     * character and no other operators. A custom separator may be provided as an argument.\n     * @private\n     * @param {String} sep Optional; Separator string. If missing, the default separator (\".\") is used.\n     */\n    var setSimpleOptions = function(sep){\n        var sepOpts = {};\n        if (!(typeof sep === $STRING && sep.length === 1)){\n            sep = '.';\n        }\n        sepOpts[sep] = {exec: $PROPERTY};\n        opt.prefixes = {};\n        opt.containers = {};\n        opt.separators = sepOpts;\n    };\n\n    /**\n     * Alter PathToolkit configuration. Takes an options hash which may include\n     * multiple settings to change at once. If the path syntax is changed by\n     * changing special characters, the cache is wiped. Each option group is\n     * REPLACED by the new option group passed in. If an option group is not\n     * included in the options hash, it is not changed.\n     * @public\n     * @param {Object} options Option hash. For sample input, see `setDefaultOptions` above.\n     */\n    _this.setOptions = function(options){\n        if (options.prefixes){\n            opt.prefixes = options.prefixes;\n            cache = {};\n        }\n        if (options.separators){\n            opt.separators = options.separators;\n            cache = {};\n        }\n        if (options.containers){\n            opt.containers = options.containers;\n            cache = {};\n        }\n        if (typeof options.cache !== $UNDEFINED){\n            opt.useCache = !!options.cache;\n        }\n        if (typeof options.simple !== $UNDEFINED){\n            var tempCache = opt.useCache; // preserve these two options after \"setDefaultOptions\"\n            var tempForce = opt.force;\n            \n            opt.simple = truthify(options.simple);\n            if (opt.simple){\n                setSimpleOptions();\n            }\n            else {\n                setDefaultOptions();\n                opt.useCache = tempCache;\n                opt.force = tempForce;\n            }\n            cache = {};\n        }\n        if (typeof options.force !== $UNDEFINED){\n            opt.force = truthify(options.force);\n        }\n        updateRegEx();\n    };\n\n    /**\n     * Sets use of keypath cache to enabled or disabled, depending on input value.\n     * @public\n     * @param {Any} val Value which will be interpreted as a boolean using `truthify`. \"true\" will enable cache; \"false\" will disable.\n     */\n    _this.setCache = function(val){\n        opt.useCache = truthify(val);\n    };\n    /**\n     * Enables use of keypath cache.\n     * @public\n     */\n    _this.setCacheOn = function(){\n        opt.useCache = true;\n    };\n    /**\n     * Disables use of keypath cache.\n     * @public\n     */\n    _this.setCacheOff = function(){\n        opt.useCache = false;\n    };\n\n    /**\n     * Sets \"force\" option when setting values in an object, depending on input value.\n     * @public\n     * @param {Any} val Value which will be interpreted as a boolean using `truthify`. \"true\" enables \"force\"; \"false\" disables.\n     */\n    _this.setForce = function(val){\n        opt.force = truthify(val);\n    };\n    /**\n     * Enables \"force\" option when setting values in an object.\n     * @public\n     */\n    _this.setForceOn = function(){\n        opt.force = true;\n    };\n    /**\n     * Disables \"force\" option when setting values in an object.\n     * @public\n     */\n    _this.setForceOff = function(){\n        opt.force = false;\n    };\n\n    /**\n     * Shortcut function to alter PathToolkit syntax to a \"simple\" mode that only uses\n     * separators and no other operators. \"Simple\" mode is enabled or disabled according\n     * to the first argument and the separator may be customized with the second\n     * argument when enabling \"simple\" mode.\n     * @public\n     * @param {Any} val Value which will be interpreted as a boolean using `truthify`. \"true\" enables \"simple\" mode; \"false\" disables.\n     * @param {String} sep Separator string to use in place of the default \".\"\n     */\n    _this.setSimple = function(val, sep){\n        var tempCache = opt.useCache; // preserve these two options after \"setDefaultOptions\"\n        var tempForce = opt.force;\n        opt.simple = truthify(val);\n        if (opt.simple){\n            setSimpleOptions(sep);\n            updateRegEx();\n        }\n        else {\n            setDefaultOptions();\n            updateRegEx();\n            opt.useCache = tempCache;\n            opt.force = tempForce;\n        }\n        cache = {};\n    };\n    \n    /**\n     * Enables \"simple\" mode\n     * @public\n     * @param {String} sep Separator string to use in place of the default \".\"\n     * @see setSimple\n     */\n    _this.setSimpleOn = function(sep){\n        opt.simple = true;\n        setSimpleOptions(sep);\n        updateRegEx();\n        cache = {};\n    };\n    \n    /**\n     * Disables \"simple\" mode, restores default PathToolkit syntax\n     * @public\n     * @see setSimple\n     * @see setDefaultOptions\n     */\n    _this.setSimpleOff = function(){\n        var tempCache = opt.useCache; // preserve these two options after \"setDefaultOptions\"\n        var tempForce = opt.force;\n        opt.simple = false;\n        setDefaultOptions();\n        updateRegEx();\n        opt.useCache = tempCache;\n        opt.force = tempForce;\n        cache = {};\n    };\n\n    /**\n     * Modify the property separator in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for this operation.\n     */\n    _this.setSeparatorProperty = function(val){\n        if (typeof val === $STRING && val.length === 1){\n            if (val !== $WILDCARD && (!opt.separators[val] || opt.separators[val].exec === $PROPERTY) && !(opt.prefixes[val] || opt.containers[val])){\n                updateOptionChar(opt.separators, $PROPERTY, val);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setSeparatorProperty - value already in use');\n            }\n        }\n        else {\n            throw new Error('setSeparatorProperty - invalid value');\n        }\n    };\n\n    /**\n     * Modify the collection separator in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for this operation.\n     */\n    _this.setSeparatorCollection = function(val){\n        if (typeof val === $STRING && val.length === 1){\n            if (val !== $WILDCARD && (!opt.separators[val] || opt.separators[val].exec === $COLLECTION) && !(opt.prefixes[val] || opt.containers[val])){\n                updateOptionChar(opt.separators, $COLLECTION, val);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setSeparatorCollection - value already in use');\n            }\n        }\n        else {\n            throw new Error('setSeparatorCollection - invalid value');\n        }\n    };\n\n    /**\n     * Modify the parent prefix in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for this operation.\n     */\n    _this.setPrefixParent = function(val){\n        if (typeof val === $STRING && val.length === 1){\n            if (val !== $WILDCARD && (!opt.prefixes[val] || opt.prefixes[val].exec === $PARENT) && !(opt.separators[val] || opt.containers[val])){\n                updateOptionChar(opt.prefixes, $PARENT, val);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setPrefixParent - value already in use');\n            }\n        }\n        else {\n            throw new Error('setPrefixParent - invalid value');\n        }\n    };\n\n    /**\n     * Modify the root prefix in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for this operation.\n     */\n    _this.setPrefixRoot = function(val){\n        if (typeof val === $STRING && val.length === 1){\n            if (val !== $WILDCARD && (!opt.prefixes[val] || opt.prefixes[val].exec === $ROOT) && !(opt.separators[val] || opt.containers[val])){\n                updateOptionChar(opt.prefixes, $ROOT, val);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setPrefixRoot - value already in use');\n            }\n        }\n        else {\n            throw new Error('setPrefixRoot - invalid value');\n        }\n    };\n\n    /**\n     * Modify the placeholder prefix in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for this operation.\n     */\n    _this.setPrefixPlaceholder = function(val){\n        if (typeof val === $STRING && val.length === 1){\n            if (val !== $WILDCARD && (!opt.prefixes[val] || opt.prefixes[val].exec === $PLACEHOLDER) && !(opt.separators[val] || opt.containers[val])){\n                updateOptionChar(opt.prefixes, $PLACEHOLDER, val);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setPrefixPlaceholder - value already in use');\n            }\n        }\n        else {\n            throw new Error('setPrefixPlaceholder - invalid value');\n        }\n    };\n\n    /**\n     * Modify the context prefix in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for this operation.\n     */\n    _this.setPrefixContext = function(val){\n        if (typeof val === $STRING && val.length === 1){\n            if (val !== $WILDCARD && (!opt.prefixes[val] || opt.prefixes[val].exec === $CONTEXT) && !(opt.separators[val] || opt.containers[val])){\n                updateOptionChar(opt.prefixes, $CONTEXT, val);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setPrefixContext - value already in use');\n            }\n        }\n        else {\n            throw new Error('setPrefixContext - invalid value');\n        }\n    };\n\n    /**\n     * Modify the property container characters in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for the container opener.\n     * @param {String} closer New character to use for the container closer.\n     */\n    _this.setContainerProperty = function(val, closer){\n        if (typeof val === $STRING && val.length === 1 && typeof closer === $STRING && closer.length === 1){\n            if (val !== $WILDCARD && (!opt.containers[val] || opt.containers[val].exec === $PROPERTY) && !(opt.separators[val] || opt.prefixes[val])){\n                updateOptionChar(opt.containers, $PROPERTY, val, closer);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setContainerProperty - value already in use');\n            }\n        }\n        else {\n            throw new Error('setContainerProperty - invalid value');\n        }\n    };\n\n    /**\n     * Modify the single quote container characters in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for the container opener.\n     * @param {String} closer New character to use for the container closer.\n     */\n    _this.setContainerSinglequote = function(val, closer){\n        if (typeof val === $STRING && val.length === 1 && typeof closer === $STRING && closer.length === 1){\n            if (val !== $WILDCARD && (!opt.containers[val] || opt.containers[val].exec === $SINGLEQUOTE) && !(opt.separators[val] || opt.prefixes[val])){\n                updateOptionChar(opt.containers, $SINGLEQUOTE, val, closer);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setContainerSinglequote - value already in use');\n            }\n        }\n        else {\n            throw new Error('setContainerSinglequote - invalid value');\n        }\n    };\n\n    /**\n     * Modify the double quote container characters in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for the container opener.\n     * @param {String} closer New character to use for the container closer.\n     */\n    _this.setContainerDoublequote = function(val, closer){\n        if (typeof val === $STRING && val.length === 1 && typeof closer === $STRING && closer.length === 1){\n            if (val !== $WILDCARD && (!opt.containers[val] || opt.containers[val].exec === $DOUBLEQUOTE) && !(opt.separators[val] || opt.prefixes[val])){\n                updateOptionChar(opt.containers, $DOUBLEQUOTE, val, closer);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setContainerDoublequote - value already in use');\n            }\n        }\n        else {\n            throw new Error('setContainerDoublequote - invalid value');\n        }\n    };\n\n    /**\n     * Modify the function call container characters in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for the container opener.\n     * @param {String} closer New character to use for the container closer.\n     */\n    _this.setContainerCall = function(val, closer){\n        if (typeof val === $STRING && val.length === 1 && typeof closer === $STRING && closer.length === 1){\n            if (val !== $WILDCARD && (!opt.containers[val] || opt.containers[val].exec === $CALL) && !(opt.separators[val] || opt.prefixes[val])){\n                updateOptionChar(opt.containers, $CALL, val, closer);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setContainerCall - value already in use');\n            }\n        }\n        else {\n            throw new Error('setContainerCall - invalid value');\n        }\n    };\n\n    /**\n     * Modify the eval property container characters in the PathToolkit syntax.\n     * @public\n     * @param {String} val New character to use for the container opener.\n     * @param {String} closer New character to use for the container closer.\n     */\n    _this.setContainerEvalProperty = function(val, closer){\n        if (typeof val === $STRING && val.length === 1 && typeof closer === $STRING && closer.length === 1){\n            if (val !== $WILDCARD && (!opt.containers[val] || opt.containers[val].exec === $EVALPROPERTY) && !(opt.separators[val] || opt.prefixes[val])){\n                updateOptionChar(opt.containers, $EVALPROPERTY, val, closer);\n                updateRegEx();\n                cache = {};\n            }\n            else {\n                throw new Error('setContainerEvalProperty - value already in use');\n            }\n        }\n        else {\n            throw new Error('setContainerProperty - invalid value');\n        }\n    };\n\n    /**\n     * Reset all PathToolkit options to their default values.\n     * @public\n     */\n    _this.resetOptions = function(){\n        setDefaultOptions();\n        updateRegEx();\n        cache = {};\n    };\n\n    // Initialize option set\n    setDefaultOptions();\n    updateRegEx();\n\n    // Apply custom options if provided as argument to constructor\n    options && _this.setOptions(options);\n\n};\n\nexport default PathToolkit;\n"],"names":[],"mappings":"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","sourceRoot":"/source/"}